{"version":3,"sources":["../../src/typescript/codeGeneration.js"],"names":["generateSource","typeDeclarationForGraphQLType","interfaceVariablesDeclarationForOperation","interfaceDeclarationForOperation","interfaceDeclarationForFragment","propertiesFromFields","propertyFromField","propertyDeclarations","uniqWith","require","getRegisterFunction","operationType","context","generator","printOnNewline","typesUsed","forEach","type","operations","operation","opName","operationName","hasVariables","printNewline","docName","fragments","fragmentsReferenced","map","name","source","join","ifName","interfaceNameFromOperation","variablesIfName","register","output","enumerationDeclaration","structDeclarationForInputObjectType","description","values","getValues","printNewlineIfNeeded","nValues","length","value","i","interfaceName","properties","getFields","variables","fields","fragmentSpreads","extendTypes","f","fragmentName","typeCondition","inlineFragments","concat","fragment","p1","p2","fieldName","typeName","forceNullable","field","fieldType","responseName","propertyName","property","namedType","bareTypeName","singularize","isArray","ofType","isNullable","isComposite","inInterface"],"mappings":"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","file":"codeGeneration.js","sourcesContent":["import {\n  GraphQLError,\n  getNamedType,\n  isCompositeType,\n  isAbstractType,\n  isEqualType,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLID,\n  GraphQLInputObjectType\n} from 'graphql'\n\nimport  { isTypeProperSuperTypeOf } from '../utilities/graphql';\n\nimport { camelCase, pascalCase } from 'change-case';\nimport Inflector from 'inflected';\nconst uniqWith = require(\"lodash.uniqwith\");\n\nimport {\n  join,\n  wrap,\n} from '../utilities/printing';\n\nimport CodeGenerator from '../utilities/CodeGenerator';\n\nimport {\n  interfaceDeclaration,\n  propertyDeclaration,\n} from './language';\n\nimport {\n  typeNameFromGraphQLType,\n} from './types';\n\n\nfunction getRegisterFunction(operationType) {\n    switch (operationType) {\n    case \"mutation\":\n        return \"registerMutationOperation\";\n    case \"subscription\":\n        return \"registerSubscription\";\n    default:\n        return \"registerQueryOperation\";\n    }\n}\n\nexport function generateSource(context) {\n  const generator = new CodeGenerator(context);\n\n  generator.printOnNewline('//  This file was automatically generated and should not be edited.');\n  generator.printOnNewline('/* tslint:disable */');\n  generator.printOnNewline('import { registerQueryOperation, registerMutationOperation, registerSubscription } from \"../../lib/client/apollo-stuff\";');\n    \n  typeDeclarationForGraphQLType(context.typesUsed.forEach(type =>\n    typeDeclarationForGraphQLType(generator, type)\n  ));\n    Object.values(context.operations).forEach(operation => {\n    const opName = operation.operationName;\n    const hasVariables = interfaceVariablesDeclarationForOperation(generator, operation);\n    interfaceDeclarationForOperation(generator, operation);\n    generator.printNewline();\n    const docName = `${opName}Document`;\n    const fragments = operation.fragmentsReferenced.map(name => context.fragments[name].source).join('\\n');\n    generator.printOnNewline(`const ${docName} = \\`${fragments} ${operation.source}\\`;`);\n    const ifName = interfaceNameFromOperation(operation);    \n    generator.printNewline();\n    const variablesIfName = hasVariables ? ifName + \"Variables\" : \"{}\";\n    const register = getRegisterFunction(operation.operationType);\n    generator.printOnNewline(`export const ${opName} = ${register}<${variablesIfName}, ${ifName}>(${docName});`);\n  })\n  Object.values(context.fragments).forEach(operation =>\n    interfaceDeclarationForFragment(generator, operation)\n  );\n\n  generator.printOnNewline('/* tslint:enable */');\n  generator.printNewline();\n\n  return generator.output;\n}\n\nexport function typeDeclarationForGraphQLType(generator, type) {\n  if (type instanceof GraphQLEnumType) {\n    enumerationDeclaration(generator, type);\n  } else if (type instanceof GraphQLInputObjectType) {\n    structDeclarationForInputObjectType(generator, type);\n  }\n}\n\nfunction enumerationDeclaration(generator, type) {\n  const { name, description } = type;\n  const values = type.getValues();\n\n  generator.printNewlineIfNeeded();\n  generator.printOnNewline(description && `// ${description}`);\n  generator.printOnNewline(`export type ${name} =`);\n  const nValues = values.length;\n  values.forEach((value, i) => \n    generator.printOnNewline(`  \"${value.value}\"${i === nValues-1 ? ';' : ' |'}${wrap(' // ', value.description)}`)\n  );\n  generator.printNewline();\n}\n\nfunction structDeclarationForInputObjectType(\n  generator,\n  type\n  ) {\n  const interfaceName = pascalCase(type.name);\n  interfaceDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    const properties = propertiesFromFields(generator.context, Object.values(type.getFields()));\n    propertyDeclarations(generator, properties, true);\n  });\n}\n\nfunction interfaceNameFromOperation({operationName, operationType}) {\n  switch (operationType) {\n    case 'query':\n      return `${pascalCase(operationName)}Query`;\n      break;\n    case 'mutation':\n      return `${pascalCase(operationName)}Mutation`;\n      break;\n    case 'subscription':\n      return `${pascalCase(operationName)}Subscription`;\n      break;\n    default:\n      throw new GraphQLError(`Unsupported operation type \"${operationType}\"`);\n  }\n}\n\nexport function interfaceVariablesDeclarationForOperation(\n  generator,\n  {\n    operationName,\n    operationType,\n    variables,\n    fields,\n    fragmentsReferenced,\n    source,\n  }\n) {\n  if (!variables || variables.length < 1) {\n    return false;\n  }\n  const interfaceName = `${interfaceNameFromOperation({operationName, operationType})}Variables`;\n\n  interfaceDeclaration(generator, {\n    interfaceName,\n  }, () => {\n    const properties = propertiesFromFields(generator.context, variables);\n    propertyDeclarations(generator, properties, true);\n  });\n  return true;\n}\n\nexport function interfaceDeclarationForOperation(\n  generator,\n  {\n    operationName,\n    operationType,\n    variables,\n    fields,\n    fragmentSpreads,\n    fragmentsReferenced,\n    source,\n  }\n) {\n  const interfaceName = interfaceNameFromOperation({operationName, operationType});\n  interfaceDeclaration(generator, {\n    interfaceName,\n    extendTypes: fragmentSpreads ? fragmentSpreads.map(f => `${pascalCase(f)}`) : null,\n  }, () => {\n    const properties = propertiesFromFields(generator.context, fields);\n    propertyDeclarations(generator, properties, true);\n  });\n}\n\nexport function interfaceDeclarationForFragment(\n  generator,\n  {\n    fragmentName,\n    typeCondition,\n    fields,\n    inlineFragments,\n    fragmentSpreads,\n    source,\n  }\n) {\n  const interfaceName = `${pascalCase(fragmentName)}`;\n\n  interfaceDeclaration(generator, {\n    interfaceName,\n    extendTypes: fragmentSpreads ? fragmentSpreads.map(f => `${pascalCase(f)}`) : null,\n  }, () => {\n    const properties = uniqWith(propertiesFromFields(generator.context, fields)\n    .concat(...(inlineFragments || []).map(fragment =>\n      propertiesFromFields(generator.context, fragment.fields, true)\n    )), (p1, p2) => {\n      return (p1.fieldName === p2.fieldName) && (p1.typeName || p2.typeName);\n    });\n\n    propertyDeclarations(generator, properties, true);\n  });\n}\n\nexport function propertiesFromFields(context, fields, forceNullable) {\n  return fields.map(field => propertyFromField(context, field, forceNullable));\n}\n\nexport function propertyFromField(context, field, forceNullable) {\n  let { name: fieldName, type: fieldType, description, fragmentSpreads, inlineFragments } = field;\n  fieldName = fieldName || field.responseName;\n\n  const propertyName = fieldName;\n\n  let property = { fieldName, fieldType, propertyName, description };\n\n  const namedType = getNamedType(fieldType);\n\n  if (isCompositeType(namedType)) {\n    const bareTypeName = pascalCase(Inflector.singularize(propertyName));\n    const typeName = typeNameFromGraphQLType(context, fieldType, bareTypeName);\n    let isArray = false;\n    if (fieldType instanceof GraphQLList) {\n      isArray = true;\n    } else if (fieldType instanceof GraphQLNonNull && fieldType.ofType instanceof GraphQLList) {\n      isArray = true\n    }\n    let isNullable = true;\n    if (fieldType instanceof GraphQLNonNull && !forceNullable) {\n      isNullable = false;\n    }\n    return {\n      ...property,\n      typeName, bareTypeName, fields: field.fields, isComposite: true, fragmentSpreads, inlineFragments, fieldType,\n      isArray, isNullable,\n    };\n  } else {\n    const typeName = typeNameFromGraphQLType(context, fieldType);\n    return { ...property, typeName, isComposite: false, fieldType };\n  }\n}\n\nexport function propertyDeclarations(generator, properties, inInterface) {\n  if (!properties) return;\n  properties.forEach(property => {\n    if (property.fields && property.fields.length > 0 || property.inlineFragments && property.inlineFragments.length > 0) {\n      propertyDeclaration(generator, {...property, inInterface}, () => {\n        const properties = propertiesFromFields(generator.context, property.fields)\n        .concat(...(property.inlineFragments || []).map(fragment =>\n          propertiesFromFields(generator.context, fragment.fields, true)\n        ));\n        propertyDeclarations(generator, properties);\n      });\n    } else {\n      propertyDeclaration(generator, {...property, inInterface});\n    }\n  });\n}\n"]}